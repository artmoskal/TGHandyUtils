"""Clean handlers - recipient system only, no legacy code."""

import asyncio
import time
import threading
from typing import Dict, List, Tuple, Optional, Any
from collections import defaultdict
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram import Bot

from bot import router
from states.recipient_states import RecipientState
from keyboards.recipient import (
    get_recipient_management_keyboard,
    get_platform_selection_keyboard,
    get_recipient_selection_keyboard,
    get_recipient_edit_keyboard,
    get_transcription_keyboard,
    get_main_menu_keyboard,
    get_settings_main_keyboard,
    get_notification_settings_keyboard,
    get_delete_confirmation_keyboard,
    get_back_to_settings_keyboard,
    get_post_task_actions_keyboard
)
from core.container import container
from models.unified_recipient import UnifiedRecipientCreate
from models.task import TaskCreate
from core.logging import get_logger
from core.exceptions import TranscriptionError

logger = get_logger(__name__)

# Threading system for grouping messages within 1 second
message_threads = defaultdict(list)
last_message_time = defaultdict(float)
_message_threads_lock = threading.Lock()
THREAD_TIMEOUT = 1.0  # 1 second timeout


async def handle_task_creation_response(message: Message, success: bool, feedback: Optional[str], actions: Optional[Dict[str, List[Dict[str, str]]]]):
    """Unified handler for task creation responses with action buttons."""
    if not success:
        await message.reply("âŒ Error creating task. Please try again.")
        return
    
    # If we have actions, show keyboard with action buttons
    if actions and (actions.get("remove_actions") or actions.get("add_actions")):
        keyboard = get_post_task_actions_keyboard(actions)
        await message.reply(feedback or "âœ… Task created!", reply_markup=keyboard, parse_mode='Markdown')
    else:
        # No actions available, just show the feedback
        await message.reply(feedback or "âœ… Task created!", parse_mode='Markdown')


async def process_user_input(text: str, user_id: int, message_obj: Message, state: FSMContext) -> bool:
    """Process user text input with threading support - groups messages within 1 second."""
    try:
        recipient_service = container.clean_recipient_service()
        recipients = recipient_service.get_enabled_recipients(user_id)
        
        if not recipients:
            await message_obj.reply(
                "âŒ NO RECIPIENTS CONFIGURED\n\n"
                "You need to connect a recipient first!\n\n"
                "ğŸš€ Use /recipients to add your Todoist or Trello account."
            )
            return False

        # Get user full name for threading
        user_full_name = message_obj.from_user.full_name or "User"
        
        # Add to threading system
        current_time = time.time()
        with _message_threads_lock:
            message_threads[user_id].append((user_full_name, text))
            last_message_time[user_id] = current_time
        
        # Check if enough time has passed since the last message
        if len(message_threads[user_id]) > 0:
            await asyncio.sleep(THREAD_TIMEOUT)
            if current_time == last_message_time[user_id]:  # No new messages received
                # Process the complete thread
                with _message_threads_lock:
                    thread_content = message_threads[user_id].copy()
                    message_threads[user_id].clear()  # Clear the thread
                
                # Get user preferences
                user_prefs = recipient_service.get_user_preferences(user_id)
                owner_name = user_prefs.owner_name if user_prefs else "User"
                location = user_prefs.location if user_prefs else None
                
                await process_thread_with_photos(message_obj, thread_content, owner_name, location, user_id)
                return True
        
        return True
        
    except Exception as e:
        logger.error(f"Error processing user input: {e}")
        await message_obj.reply("An error occurred while processing your message. Please try again.")
        return False


async def process_user_input_with_photo(text: str, user_id: int, message_obj: Message, state: FSMContext, bot: Bot) -> bool:
    """Process user input that includes a photo, with threading support."""
    try:
        recipient_service = container.clean_recipient_service()
        recipients = recipient_service.get_enabled_recipients(user_id)
        
        if not recipients:
            await message_obj.reply(
                "âŒ NO RECIPIENTS CONFIGURED\n\n"
                "You need to connect a recipient first!\n\n"
                "ğŸš€ Use /recipients to add your Todoist or Trello account."
            )
            return False

        # Process the screenshot or document first
        processing_msg = await message_obj.answer("ğŸ“¸ Processing image...")
        
        from core.initialization import services
        image_service = services.get_image_processing_service()
        
        # Handle both inline photos and document attachments
        if message_obj.photo:
            image_result = await image_service.process_image_message(message_obj.photo, bot)
        elif message_obj.document:
            image_result = await image_service.process_image_message(message_obj.document, bot)
        else:
            await processing_msg.delete()
            await message_obj.reply("âŒ No image found to process.")
            return False
        
        await processing_msg.delete()
        
        extracted_text = image_result.get('extracted_text', '')
        summary = image_result.get('summary', '')
        
        if not extracted_text.strip() and not text.strip():
            await message_obj.reply(
                "ğŸ“¸ **Screenshot Processed**\n\n"
                f"ğŸ” **Analysis:** {summary}\n\n"
                "âš ï¸ No text was found in the image and no caption provided to create a task from."
            )
            return False

        # Determine the correct user name (handle forwarded messages)
        if message_obj.forward_from:
            user_full_name = message_obj.forward_from.full_name
        elif message_obj.forward_sender_name:
            user_full_name = message_obj.forward_sender_name
        else:
            user_full_name = message_obj.from_user.full_name

        # Combine screenshot content with any text caption
        combined_content = ""
        if text.strip():
            combined_content += f"[CAPTION] {text.strip()}\n\n"
        if extracted_text.strip():
            combined_content += f"[SCREENSHOT TEXT] {extracted_text}\n\n"
        if summary.strip():
            combined_content += f"[SCREENSHOT DESCRIPTION] {summary}"
        
        logger.error(f"ğŸ” DEBUG: Photo processing - combined content: {combined_content}")
        
        # Add to threading system
        current_time = time.time()
        with _message_threads_lock:
            message_threads[user_id].append((user_full_name, combined_content, image_result))
            last_message_time[user_id] = current_time
        
        # Check if enough time has passed since the last message
        if len(message_threads[user_id]) > 0:
            await asyncio.sleep(THREAD_TIMEOUT)
            if current_time == last_message_time[user_id]:  # No new messages received
                # Process the complete thread
                with _message_threads_lock:
                    thread_content = message_threads[user_id].copy()
                    message_threads[user_id].clear()  # Clear the thread
                
                # Get user preferences
                user_prefs = recipient_service.get_user_preferences(user_id)
                owner_name = user_prefs.owner_name if user_prefs else "User"
                location = user_prefs.location if user_prefs else None
                
                await process_thread_with_photos(message_obj, thread_content, owner_name, location, user_id)
                return True
        
        return True
        
    except Exception as e:
        logger.error(f"Error processing user input with photo: {e}")
        await message_obj.reply("An error occurred while processing your screenshot. Please try again.")
        return False


async def process_thread_with_photos(message: Message, thread_content: List[Tuple], 
                                    owner_name: str, location: str, owner_id: int):
    """Process a thread of messages that may include photos and create a task."""
    try:
        # Separate text content and find any screenshot data
        text_content = []
        screenshot_data = None
        
        for item in thread_content:
            if len(item) == 3:  # (user, content, image_result)
                user, content, image_result = item
                text_content.append((user, content))
                if not screenshot_data:  # Use first screenshot found
                    screenshot_data = image_result
            else:  # (user, content)
                text_content.append(item)
        
        # Concatenate thread content
        concatenated_content = "\n".join([f"{sender}: {text}" for sender, text in text_content])
        
        logger.error(f"ğŸ” DEBUG: Processing thread with photos - {len(thread_content)} messages")
        logger.error(f"ğŸ” DEBUG: Content: {concatenated_content}")
        logger.error(f"ğŸ” DEBUG: Has screenshot: {screenshot_data is not None}")
        
        # Parse using recipient parsing service
        from core.initialization import services
        parsing_service = services.get_parsing_service()
        
        parsed_task_dict = parsing_service.parse_content_to_task(
            concatenated_content,
            owner_name=owner_name,
            location=location
        )
        
        if parsed_task_dict:
            logger.error(f"ğŸ” DEBUG: LLM parsed successfully: {parsed_task_dict}")
            task_data = TaskCreate(**parsed_task_dict)
        else:
            logger.error(f"ğŸ” DEBUG: LLM parsing failed, using fallback")
            # Fallback: all tasks without time go to tomorrow 9AM UTC
            from datetime import datetime, timezone, timedelta
            tomorrow = datetime.now(timezone.utc) + timedelta(days=1)
            due_time = tomorrow.replace(hour=9, minute=0, second=0, microsecond=0).isoformat()
            
            task_data = TaskCreate(
                title=concatenated_content[:100],  # Truncate long titles
                description=concatenated_content,
                due_time=due_time
            )
        
        # Create task using recipient task service WITH screenshot data
        task_service = container.clean_recipient_task_service()
        success, feedback, actions = task_service.create_task_for_recipients(
            user_id=owner_id,
            title=task_data.title,
            description=task_data.description,
            due_time=task_data.due_time,
            specific_recipients=None,  # Use default recipients
            screenshot_data=screenshot_data
        )
        
        # Use unified response handler
        await handle_task_creation_response(message, success, feedback, actions)
            
    except Exception as e:
        logger.error(f"Error processing thread with photos: {e}")
        await message.reply("âŒ Error creating task from messages. Please try again.")


async def process_thread(message: Message, thread_content: List[Tuple[str, str]], 
                        owner_name: str, location: str, owner_id: int):
    """Process a thread of messages and create a single task."""
    try:
        # Concatenate thread content
        concatenated_content = "\n".join([f"{sender}: {text}" for sender, text in thread_content])
        
        logger.error(f"ğŸ” DEBUG: Processing thread with {len(thread_content)} messages")
        logger.error(f"ğŸ” DEBUG: Concatenated content: {concatenated_content}")
        
        # Parse using recipient parsing service
        from core.initialization import services
        parsing_service = services.get_parsing_service()
        
        parsed_task_dict = parsing_service.parse_content_to_task(
            concatenated_content,
            owner_name=owner_name,
            location=location
        )
        
        if parsed_task_dict:
            logger.error(f"ğŸ” DEBUG: LLM parsed successfully: {parsed_task_dict}")
            task_data = TaskCreate(**parsed_task_dict)
        else:
            logger.error(f"ğŸ” DEBUG: LLM parsing failed, using fallback")
            # Fallback: all tasks without time go to tomorrow 9AM UTC
            from datetime import datetime, timezone, timedelta
            tomorrow = datetime.now(timezone.utc) + timedelta(days=1)
            due_time = tomorrow.replace(hour=9, minute=0, second=0, microsecond=0).isoformat()
            
            task_data = TaskCreate(
                title=concatenated_content[:100],  # Truncate long titles
                description=concatenated_content,
                due_time=due_time
            )
        
        # Create task using recipient task service
        task_service = container.clean_recipient_task_service()
        success, feedback, actions = task_service.create_task_for_recipients(
            user_id=owner_id,
            title=task_data.title,
            description=task_data.description,
            due_time=task_data.due_time,
            specific_recipients=None  # Use default recipients
        )
        
        # Use unified response handler
        await handle_task_creation_response(message, success, feedback, actions)
            
    except Exception as e:
        logger.error(f"Error processing thread: {e}")
        await message.reply("âŒ Error creating task from messages. Please try again.")


@router.message(Command('start'))
async def cmd_start(message: Message, state: FSMContext):
    """Start command - show recipient management."""
    await message.reply(
        "ğŸ¯ Welcome to Task Bot!\n\n"
        "I help you create tasks on your Todoist and Trello accounts.\n\n"
        "ğŸš€ QUICK START:\n"
        "1ï¸âƒ£ Add your accounts: /recipients\n"
        "2ï¸âƒ£ Create tasks: /create_task\n\n"
        "ğŸ’¡ First time? Start with /recipients to connect your Todoist or Trello account!"
    )


@router.message(Command('recipients'))
async def show_recipient_management(message: Message, state: FSMContext):
    """Show recipient management interface."""
    user_id = message.from_user.id
    
    try:
        recipient_service = container.clean_recipient_service()
        recipients = recipient_service.get_all_recipients(user_id)
        
        keyboard = get_recipient_management_keyboard(recipients)
        
        if recipients:
            text = "ğŸ¯ PLATFORM MANAGEMENT\n\n"
            text += "ğŸ“± Your connected accounts:\n\n"
            for recipient in recipients:
                status = "âœ… Active" if recipient.enabled else "âŒ Disabled"
                platform_emoji = "ğŸ“" if recipient.platform_type == "todoist" else "ğŸ“‹"
                text += f"{platform_emoji} {recipient.name}\n   Status: {status}\n\n"
            text += "ğŸ’¡ Tap any account above to edit it."
        else:
            text = "ğŸ¯ PLATFORM SETUP\n\n"
            text += "ğŸ‘‹ Welcome! You haven't connected any accounts yet.\n\n"
            text += "ğŸ¯ What are recipients?\n"
            text += "Recipients are your Todoist/Trello accounts where tasks will be created.\n\n"
            text += "ğŸš€ Get started by adding your first account below!"
        
        await message.reply(text, reply_markup=keyboard)
        
    except Exception as e:
        logger.error(f"Failed to show recipient management for user {user_id}: {e}")
        await message.reply("Error loading recipient management. Please try again.")


@router.callback_query(lambda c: c.data == "add_user_platform")
async def add_user_platform(callback_query: CallbackQuery, state: FSMContext):
    """Start adding user's own account."""
    keyboard = get_platform_selection_keyboard()
    
    await callback_query.message.edit_text(
        "ğŸ”§ Add Your Account\n\n"
        "Select the type of account you want to add:",
        reply_markup=keyboard
    )
    
    await state.set_state(RecipientState.selecting_platform_type)
    await callback_query.answer()


@router.callback_query(lambda c: c.data.startswith("platform_type_"))
async def handle_platform_type_selection(callback_query: CallbackQuery, state: FSMContext):
    """Handle platform type selection."""
    platform_type = callback_query.data.replace("platform_type_", "")
    
    # Don't overwrite mode if it's already set (e.g., from shared recipient flow)
    state_data = await state.get_data()
    current_mode = state_data.get('mode', 'user_platform')
    
    logger.error(f"ğŸ” PLATFORM TYPE SELECTION: user={callback_query.from_user.id}, platform={platform_type}, current_mode={current_mode}, state_data={state_data}")
    
    await state.update_data(platform_type=platform_type, mode=current_mode)
    
    help_text = get_platform_help_text(platform_type)
    
    await callback_query.message.edit_text(help_text)
    
    await state.set_state(RecipientState.waiting_for_credentials)
    await callback_query.answer()


@router.message(RecipientState.waiting_for_credentials)
async def handle_credentials_input(message: Message, state: FSMContext):
    """Handle credentials input for platform."""
    user_id = message.from_user.id
    credentials = message.text.strip()
    
    try:
        state_data = await state.get_data()
        platform_type = state_data.get('platform_type')
        mode = state_data.get('mode', 'user_platform')
        
        recipient_service = container.clean_recipient_service()
        
        logger.error(f"ğŸ” CREDENTIALS HANDLER: user={user_id}, platform={platform_type}, mode={mode}, state_data={state_data}")
        
        # For Trello, we need additional configuration (list selection)
        if platform_type == "trello":
            await state.update_data(credentials=credentials)
            await handle_trello_configuration(message, state)
            return
        
        if mode == "user_platform":
            # Add personal recipient
            name = f"My {platform_type.title()}"
            logger.error(f"ğŸ” CREATING PERSONAL RECIPIENT: {name}")
            recipient_id = recipient_service.add_personal_recipient(
                user_id=user_id,
                name=name,
                platform_type=platform_type,
                credentials=credentials,
                is_default=True
            )
            
            await message.reply(
                f"âœ… Successfully connected your {platform_type.title()}!\n\n"
                f"ğŸ¯ What's next?\n"
                f"â€¢ Use /create_task to create your first task\n"
                f"â€¢ Use /recipients to manage your accounts\n\n"
                f"ğŸ’¡ Try it now: Just send me any message and I'll create a task!"
            )
            
        elif mode == "shared_recipient":
            # Add shared recipient
            name = state_data.get('recipient_name', f"Shared {platform_type.title()}")
            logger.error(f"ğŸ” CREATING SHARED RECIPIENT: {name}")
            
            recipient_id = recipient_service.add_shared_recipient(
                user_id=user_id,
                name=name,
                platform_type=platform_type,
                credentials=credentials
            )
            
            # Create keyboard for next actions
            from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
            next_actions_keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="ğŸ“ Create Task Now", callback_data="create_task")],
                [InlineKeyboardButton(text="ğŸ“± Manage Recipients", callback_data="show_recipients")],
                [InlineKeyboardButton(text="âš™ï¸ Settings", callback_data="show_settings")]
            ])
            
            await message.reply(
                f"âœ… Successfully added shared recipient '{name}'!\n\n"
                f"ğŸ¯ Tasks created with this recipient will appear on their account.\n\n"
                f"What would you like to do next?",
                reply_markup=next_actions_keyboard
            )
        
        await state.clear()
        
    except Exception as e:
        logger.error(f"Failed to add account for user {user_id}: {e}")
        await message.reply("âŒ Failed to add account. Please check your credentials and try again.")
        await state.clear()


async def handle_trello_configuration(message: Message, state: FSMContext):
    """Handle Trello-specific configuration (board and list selection)."""
    try:
        state_data = await state.get_data()
        credentials = state_data.get('credentials')
        
        # Test credentials and get boards
        from platforms.trello import TrelloPlatform
        trello = TrelloPlatform(credentials)
        boards = trello.get_boards()
        
        if not boards:
            await message.reply(
                "âŒ Unable to fetch boards. Please check your credentials and try again.\n\n"
                "Make sure you provided: `API_KEY:TOKEN`"
            )
            await state.clear()
            return
        
        # Show boards for selection
        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
        
        keyboard_buttons = []
        for board in boards[:10]:  # Limit to first 10 boards
            keyboard_buttons.append([
                InlineKeyboardButton(
                    text=f"ğŸ“‹ {board['name']}", 
                    callback_data=f"trello_board_{board['id']}"
                )
            ])
        
        keyboard_buttons.append([
            InlineKeyboardButton(text="âŒ Cancel", callback_data="back_to_recipients")
        ])
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=keyboard_buttons)
        
        await message.reply(
            "ğŸ¯ **Trello Configuration**\n\n"
            "Select the board where you want to create tasks:",
            reply_markup=keyboard,
            parse_mode='Markdown'
        )
        
        await state.set_state(RecipientState.waiting_for_trello_config)
        
    except Exception as e:
        logger.error(f"Failed to configure Trello: {e}")
        await message.reply(
            "âŒ Failed to configure Trello. Please check your credentials.\n\n"
            "Format: `API_KEY:TOKEN`\n\n"
            "Get your credentials at: https://trello.com/app-key"
        )
        await state.clear()


@router.callback_query(lambda c: c.data.startswith("trello_board_"))
async def handle_trello_board_selection(callback_query: CallbackQuery, state: FSMContext):
    """Handle Trello board selection."""
    board_id = callback_query.data.replace("trello_board_", "")
    
    try:
        state_data = await state.get_data()
        credentials = state_data.get('credentials')
        
        # Get lists for the selected board
        from platforms.trello import TrelloPlatform
        trello = TrelloPlatform(credentials)
        lists = trello.get_lists(board_id)
        
        if not lists:
            await callback_query.answer("âŒ No lists found in this board")
            return
        
        # Store board_id and show lists for selection
        await state.update_data(board_id=board_id)
        
        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
        
        keyboard_buttons = []
        for list_item in lists:
            keyboard_buttons.append([
                InlineKeyboardButton(
                    text=f"ğŸ“ {list_item['name']}", 
                    callback_data=f"trello_list_{list_item['id']}"
                )
            ])
        
        keyboard_buttons.append([
            InlineKeyboardButton(text="Â« Back to Boards", callback_data="back_to_trello_boards"),
            InlineKeyboardButton(text="âŒ Cancel", callback_data="back_to_recipients")
        ])
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=keyboard_buttons)
        
        await callback_query.message.edit_text(
            "ğŸ¯ **Trello List Selection**\n\n"
            "Select the list where tasks will be created:",
            reply_markup=keyboard,
            parse_mode='Markdown'
        )
        
        await callback_query.answer()
        
    except Exception as e:
        logger.error(f"Failed to get Trello lists: {e}")
        await callback_query.answer("âŒ Failed to load lists")


@router.callback_query(lambda c: c.data.startswith("trello_list_"))
async def handle_trello_list_selection(callback_query: CallbackQuery, state: FSMContext):
    """Handle Trello list selection and complete setup."""
    list_id = callback_query.data.replace("trello_list_", "")
    
    try:
        state_data = await state.get_data()
        credentials = state_data.get('credentials')
        board_id = state_data.get('board_id')
        platform_type = state_data.get('platform_type')
        mode = state_data.get('mode', 'user_platform')
        
        user_id = callback_query.from_user.id
        recipient_service = container.clean_recipient_service()
        
        # Create platform config with board and list IDs
        platform_config = {
            "board_id": board_id,
            "list_id": list_id
        }
        
        if mode == "user_platform":
            # Add personal recipient
            name = f"My {platform_type.title()}"
            recipient_id = recipient_service.add_personal_recipient(
                user_id=user_id,
                name=name,
                platform_type=platform_type,
                credentials=credentials,
                platform_config=platform_config,
                is_default=True
            )
            
            await callback_query.message.edit_text(
                f"âœ… Successfully connected your {platform_type.title()}!\n\n"
                f"ğŸ¯ What's next?\n"
                f"â€¢ Use /create_task to create your first task\n"
                f"â€¢ Use /recipients to manage your accounts\n\n"
                f"ğŸ’¡ Try it now: Just send me any message and I'll create a task!"
            )
            
        elif mode == "shared_recipient":
            # Add shared recipient
            name = state_data.get('recipient_name', f"Shared {platform_type.title()}")
            
            recipient_id = recipient_service.add_shared_recipient(
                user_id=user_id,
                name=name,
                platform_type=platform_type,
                credentials=credentials,
                platform_config=platform_config
            )
            
            # Create keyboard for next actions
            from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
            next_actions_keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="ğŸ“ Create Task Now", callback_data="create_task")],
                [InlineKeyboardButton(text="ğŸ“± Manage Recipients", callback_data="show_recipients")],
                [InlineKeyboardButton(text="âš™ï¸ Settings", callback_data="show_settings")]
            ])
            
            await callback_query.message.edit_text(
                f"âœ… Successfully added shared recipient '{name}'!\n\n"
                f"ğŸ¯ Tasks created with this recipient will appear on their account.\n\n"
                f"What would you like to do next?",
                reply_markup=next_actions_keyboard
            )
            
        elif mode == "configure_existing":
            # Update existing recipient configuration
            existing_recipient_id = state_data.get('recipient_id')
            
            # For unified recipients, the ID is just the recipient ID
            recipient_id = int(existing_recipient_id)
            from models.unified_recipient import UnifiedRecipientUpdate
            updates = UnifiedRecipientUpdate(platform_config=platform_config)
            success = recipient_service.update_recipient(user_id, recipient_id, updates)
            
            if success:
                await callback_query.message.edit_text(
                    "âœ… **Trello Configuration Updated!**\n\n"
                    "Your Trello recipient is now configured with the selected board and list.\n\n"
                    "ğŸ¯ You can now create tasks that will appear in your Trello board!"
                )
            else:
                await callback_query.message.edit_text(
                    "âŒ Failed to update configuration. Please try again."
                )
        
        
        await state.clear()
        await callback_query.answer("âœ… Trello configured successfully!")
        
    except Exception as e:
        logger.error(f"Failed to complete Trello setup: {e}")
        await callback_query.answer("âŒ Failed to complete setup")
        await state.clear()


@router.callback_query(lambda c: c.data == "back_to_trello_boards")
async def back_to_trello_boards(callback_query: CallbackQuery, state: FSMContext):
    """Go back to Trello board selection."""
    # Re-trigger the board selection flow
    try:
        state_data = await state.get_data()
        credentials = state_data.get('credentials')
        
        from platforms.trello import TrelloPlatform
        trello = TrelloPlatform(credentials)
        boards = trello.get_boards()
        
        if not boards:
            await callback_query.answer("âŒ Unable to fetch boards")
            return
        
        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
        
        keyboard_buttons = []
        for board in boards[:10]:  # Limit to first 10 boards
            keyboard_buttons.append([
                InlineKeyboardButton(
                    text=f"ğŸ“‹ {board['name']}", 
                    callback_data=f"trello_board_{board['id']}"
                )
            ])
        
        keyboard_buttons.append([
            InlineKeyboardButton(text="âŒ Cancel", callback_data="back_to_recipients")
        ])
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=keyboard_buttons)
        
        await callback_query.message.edit_text(
            "ğŸ¯ **Trello Configuration**\n\n"
            "Select the board where you want to create tasks:",
            reply_markup=keyboard,
            parse_mode='Markdown'
        )
        
        await callback_query.answer()
        
    except Exception as e:
        logger.error(f"Failed to go back to boards: {e}")
        await callback_query.answer("âŒ Error loading boards")


@router.callback_query(lambda c: c.data == "add_shared_recipient")
async def add_shared_recipient(callback_query: CallbackQuery, state: FSMContext):
    """Start adding shared recipient."""
    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
    
    cancel_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âŒ Cancel", callback_data="back_to_recipients")]
    ])
    
    await callback_query.message.edit_text(
        "ğŸ‘¥ **Add Shared Recipient**\n\n"
        "Enter a name for this recipient (e.g., \"Wife's Trello\", \"Team Todoist\"):",
        reply_markup=cancel_keyboard,
        parse_mode='Markdown'
    )
    
    await state.set_state(RecipientState.waiting_for_recipient_name)
    await callback_query.answer()


@router.message(RecipientState.waiting_for_recipient_name)
async def handle_recipient_name(message: Message, state: FSMContext):
    """Handle recipient name input."""
    name = message.text.strip()
    
    if not name:
        await message.reply("âŒ Name cannot be empty. Please enter a name:")
        return
    
    await state.update_data(recipient_name=name, mode="shared_recipient")
    
    keyboard = get_platform_selection_keyboard()
    
    await message.reply(
        f"ğŸ‘¥ **Adding: {name}**\n\n"
        "Select the account type:",
        reply_markup=keyboard,
        parse_mode='Markdown'
    )
    
    await state.set_state(RecipientState.selecting_platform_type)


@router.callback_query(lambda c: c.data.startswith("recipient_"))
async def handle_recipient_action(callback_query: CallbackQuery, state: FSMContext):
    """Handle recipient-specific actions."""
    action_data = callback_query.data.replace("recipient_", "")
    
    if action_data.startswith("edit_"):
        recipient_id = action_data.replace("edit_", "")
        await edit_recipient(callback_query, state, recipient_id)
    elif action_data.startswith("remove_"):
        recipient_id = action_data.replace("remove_", "")
        await remove_recipient(callback_query, state, recipient_id)


@router.callback_query(lambda c: c.data.startswith("toggle_recipient_") and c.data != "toggle_recipient_ui")
async def handle_toggle_recipient(callback_query: CallbackQuery, state: FSMContext):
    """Handle recipient toggle actions."""
    recipient_id = callback_query.data.replace("toggle_recipient_", "")
    
    try:
        user_id = callback_query.from_user.id
        recipient_service = container.clean_recipient_service()
        
        # Toggle recipient enabled status
        success = recipient_service.toggle_recipient_enabled(user_id, recipient_id)
        
        if success:
            await callback_query.answer("âœ… Recipient status toggled!")
            # Refresh the edit view
            await edit_recipient(callback_query, state, recipient_id)
        else:
            await callback_query.answer("âŒ Failed to toggle recipient status")
        
    except Exception as e:
        logger.error(f"Failed to toggle recipient {recipient_id}: {e}")
        await callback_query.answer("Error toggling recipient")


async def edit_recipient(callback_query: CallbackQuery, state: FSMContext, recipient_id: str):
    """Edit recipient."""
    user_id = callback_query.from_user.id
    
    try:
        recipient_service = container.clean_recipient_service()
        recipients = recipient_service.get_all_recipients(user_id)
        
        recipient = next((r for r in recipients if r.id == recipient_id), None)
        if not recipient:
            await callback_query.answer("Recipient not found.")
            return
        
        keyboard = get_recipient_edit_keyboard(recipient_id, recipient.platform_type)
        
        config_status = ""
        if recipient.platform_type == "trello":
            # Check if Trello has configuration
            config = recipient_service.get_recipient_config(user_id, recipient_id)
            if not config or not config.get('list_id'):
                config_status = "\nâš ï¸ **Configuration needed**: Board/List not set"
        
        await callback_query.message.edit_text(
            f"âœï¸ **Edit: {recipient.name}**\n\n"
            f"Platform: {recipient.platform_type.title()}\n"
            f"Type: {recipient.type.replace('_', ' ').title()}\n"
            f"Status: {'Enabled' if recipient.enabled else 'Disabled'}{config_status}\n\n"
            "Choose an action:",
            reply_markup=keyboard,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Failed to edit recipient {recipient_id}: {e}")
        await callback_query.answer("Error loading recipient details.")


@router.callback_query(lambda c: c.data.startswith("configure_recipient_"))
async def configure_recipient(callback_query: CallbackQuery, state: FSMContext):
    """Configure existing recipient (e.g., Trello board/list setup)."""
    recipient_id = callback_query.data.replace("configure_recipient_", "")
    user_id = callback_query.from_user.id
    
    try:
        recipient_service = container.clean_recipient_service()
        recipients = recipient_service.get_all_recipients(user_id)
        
        recipient = next((r for r in recipients if r.id == recipient_id), None)
        if not recipient:
            await callback_query.answer("Recipient not found.")
            return
        
        if recipient.platform_type == "trello":
            # Get credentials and start Trello configuration
            credentials = recipient_service.get_recipient_credentials(user_id, recipient_id)
            if not credentials:
                await callback_query.answer("âŒ No credentials found for this recipient")
                return
            
            # Store data for configuration flow
            await state.update_data(
                platform_type="trello",
                credentials=credentials,
                mode="configure_existing",
                recipient_id=recipient_id
            )
            
            # Start Trello configuration
            await configure_existing_trello(callback_query, state)
        else:
            await callback_query.answer("Configuration not available for this account type")
            
    except Exception as e:
        logger.error(f"Failed to configure recipient {recipient_id}: {e}")
        await callback_query.answer("âŒ Error starting configuration")


async def configure_existing_trello(callback_query: CallbackQuery, state: FSMContext):
    """Configure existing Trello recipient with board/list selection."""
    try:
        state_data = await state.get_data()
        credentials = state_data.get('credentials')
        
        # Test credentials and get boards
        from platforms.trello import TrelloPlatform
        trello = TrelloPlatform(credentials)
        boards = trello.get_boards()
        
        if not boards:
            await callback_query.message.edit_text(
                "âŒ Unable to fetch boards. Please check if your Trello credentials are still valid.\n\n"
                "You may need to remove and re-add this recipient with fresh credentials."
            )
            await state.clear()
            return
        
        # Show boards for selection
        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
        
        keyboard_buttons = []
        for board in boards[:10]:  # Limit to first 10 boards
            keyboard_buttons.append([
                InlineKeyboardButton(
                    text=f"ğŸ“‹ {board['name']}", 
                    callback_data=f"trello_board_{board['id']}"
                )
            ])
        
        keyboard_buttons.append([
            InlineKeyboardButton(text="âŒ Cancel", callback_data="back_to_recipients")
        ])
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=keyboard_buttons)
        
        await callback_query.message.edit_text(
            "ğŸ¯ **Configure Trello**\n\n"
            "Select the board where you want to create tasks:",
            reply_markup=keyboard,
            parse_mode='Markdown'
        )
        
        await state.set_state(RecipientState.waiting_for_trello_config)
        await callback_query.answer()
        
    except Exception as e:
        logger.error(f"Failed to configure existing Trello: {e}")
        await callback_query.message.edit_text(
            "âŒ Failed to load Trello boards. Please check your credentials.\n\n"
            "You may need to remove and re-add this recipient."
        )
        await state.clear()


async def remove_recipient(callback_query: CallbackQuery, state: FSMContext, recipient_id: str):
    """Remove recipient."""
    user_id = callback_query.from_user.id
    
    try:
        recipient_service = container.clean_recipient_service()
        success = recipient_service.remove_recipient(user_id, recipient_id)
        
        if success:
            await callback_query.answer("âœ… Recipient removed!")
            
            # Refresh recipient list
            recipients = recipient_service.get_all_recipients(user_id)
            keyboard = get_recipient_management_keyboard(recipients)
            
            text = "ğŸ¯ **Recipient Management**\n\n"
            if recipients:
                text += "Your configured recipients:\n"
                for recipient in recipients:
                    status = "âœ…" if recipient.enabled else "âŒ"
                    text += f"{status} {recipient.name} ({recipient.platform_type})\n"
            else:
                text += "No recipients configured yet.\n"
            
            text += "\nRecipients are destinations where your tasks can be created."
            
            await callback_query.message.edit_text(text, reply_markup=keyboard, parse_mode='Markdown')
        else:
            await callback_query.answer("âŒ Failed to remove recipient.")
            
    except Exception as e:
        logger.error(f"Failed to remove recipient {recipient_id}: {e}")
        await callback_query.answer("Error removing recipient.")


@router.callback_query(lambda c: c.data == "recipient_settings")
async def recipient_settings(callback_query: CallbackQuery, state: FSMContext):
    """Show recipient settings."""
    user_id = callback_query.from_user.id
    
    try:
        recipient_service = container.clean_recipient_service()
        ui_enabled = recipient_service.is_recipient_ui_enabled(user_id)
        notifications_enabled = recipient_service.are_telegram_notifications_enabled(user_id)
        
        ui_status = "Enabled" if ui_enabled else "Disabled"
        ui_toggle_text = "Disable" if ui_enabled else "Enable"
        
        notifications_status = "Enabled" if notifications_enabled else "Disabled"
        notifications_toggle_text = "Disable" if notifications_enabled else "Enable"
        
        keyboard = [
            [{"text": f"{ui_toggle_text} Recipient Selection UI", "callback_data": "toggle_recipient_ui"}],
            [{"text": f"{notifications_toggle_text} Telegram Notifications", "callback_data": "toggle_telegram_notifications"}],
            [{"text": "Â« Back to Recipients", "callback_data": "back_to_recipients"}]
        ]
        
        await callback_query.message.edit_text(
            f"âš™ï¸ **Recipient Settings**\n\n"
            f"Recipient Selection UI: {ui_status}\n"
            f"Telegram Notifications: {notifications_status}\n\n"
            "â€¢ Recipient UI: When enabled, you'll be asked to choose recipients for each task.\n"
            "â€¢ Notifications: When enabled, you'll receive telegram reminders for due tasks.",
            reply_markup={"inline_keyboard": keyboard}
        )
        
    except Exception as e:
        logger.error(f"Failed to load recipient settings for user {user_id}: {e}")
        await callback_query.answer("Error loading settings.")


@router.callback_query(lambda c: c.data and c.data == "toggle_recipient_ui")
async def toggle_recipient_ui(callback_query: CallbackQuery, state: FSMContext):
    """Toggle recipient selection UI."""
    user_id = callback_query.from_user.id
    logger.info(f"Toggle recipient UI called for user {user_id}")
    
    try:
        recipient_service = container.clean_recipient_service()
        logger.debug(f"Got recipient service for user {user_id}")
        
        current_status = recipient_service.is_recipient_ui_enabled(user_id)
        logger.debug(f"Current UI status for user {user_id}: {current_status}")
        
        new_status = not current_status
        logger.debug(f"Toggling UI status for user {user_id}: {current_status} -> {new_status}")
        
        success = recipient_service.enable_recipient_ui(user_id, new_status)
        logger.debug(f"Enable recipient UI result for user {user_id}: success={success}")
        
        if success:
            status_text = "enabled" if new_status else "disabled"
            logger.info(f"Successfully toggled recipient UI for user {user_id}: {status_text}")
            await callback_query.answer(f"âœ… Recipient UI {status_text}!")
            
            # Refresh settings display
            await recipient_settings(callback_query, state)
        else:
            logger.error(f"Failed to enable recipient UI for user {user_id}: success=False")
            await callback_query.answer("âŒ Failed to update setting.")
            
    except Exception as e:
        logger.error(f"Exception in toggle recipient UI for user {user_id}: {e}", exc_info=True)
        await callback_query.answer("Error updating setting.")


@router.callback_query(lambda c: c.data == "toggle_telegram_notifications")
async def toggle_telegram_notifications(callback_query: CallbackQuery, state: FSMContext):
    """Toggle telegram notifications."""
    user_id = callback_query.from_user.id
    logger.error(f"ğŸ” TELEGRAM NOTIFICATIONS TOGGLE called for user {user_id}")
    
    try:
        recipient_service = container.clean_recipient_service()
        current_status = recipient_service.are_telegram_notifications_enabled(user_id)
        new_status = not current_status
        
        success = recipient_service.set_telegram_notifications(user_id, new_status)
        
        if success:
            status_text = "enabled" if new_status else "disabled"
            await callback_query.answer(f"âœ… Telegram notifications {status_text}!")
            
            # Refresh settings display
            await recipient_settings(callback_query, state)
        else:
            await callback_query.answer("âŒ Failed to update notification setting.")
            
    except Exception as e:
        logger.error(f"Failed to toggle telegram notifications for user {user_id}: {e}")
        await callback_query.answer("Error updating notification setting.")


def get_platform_help_text(platform_type: str) -> str:
    """Get help text for account configuration."""
    if platform_type == "todoist":
        return ("ğŸ“ TODOIST SETUP GUIDE\n\n"
                "ğŸ”— Get your API token here:\n"
                "https://todoist.com/prefs/integrations\n\n"
                "ğŸ“‹ Steps:\n"
                "1. Open the link above in your browser\n"
                "2. Scroll down to 'Developer' section\n"
                "3. Copy your API token (long string of letters/numbers)\n"
                "4. Paste it below\n\n"
                "ğŸ’¡ The token looks like: 0123456789abcdef...\n\n"
                "âœï¸ Enter your Todoist API token:")
    
    elif platform_type == "trello":
        return ("ğŸ“‹ TRELLO SETUP GUIDE\n\n"
                "ğŸ”— First, get your API key:\n"
                "https://trello.com/app-key\n\n"
                "ğŸ“‹ Steps:\n"
                "1. Open the link above to get your API Key\n"
                "2. Copy the API Key (save it somewhere)\n"
                "3. Click 'Token' link on that page\n"
                "4. Authorize the app and copy the Token\n"
                "5. Combine them as: API_KEY:TOKEN\n\n"
                "ğŸ’¡ Format example: abc123:def456789...\n\n"
                "âœï¸ Enter your credentials (API_KEY:TOKEN):")
    
    return "Enter your account credentials:"


# Command to create task with recipient selection
@router.message(Command('create_task'))
async def create_task_with_recipients(message: Message, state: FSMContext):
    """Create task with recipient selection."""
    user_id = message.from_user.id
    
    try:
        recipient_service = container.clean_recipient_service()
        recipients = recipient_service.get_enabled_recipients(user_id)
        
        if not recipients:
            await message.reply(
                "âŒ NO RECIPIENTS CONFIGURED\n\n"
                "You need to connect a recipient first!\n\n"
                "ğŸš€ Use /recipients to add your Todoist or Trello account."
            )
            return
        
        # Check if recipient UI is enabled
        if recipient_service.is_recipient_ui_enabled(user_id):
            # Show recipient selection
            keyboard = get_recipient_selection_keyboard(recipients, [])
            
            await message.reply(
                "ğŸ¯ **Create Task**\n\n"
                "First, choose recipients for your task:",
                reply_markup=keyboard,
                parse_mode='Markdown'
            )
            
            await state.set_state(RecipientState.selecting_recipients)
            await state.update_data(selected_recipients=[])
        else:
            # Use default recipients
            await message.reply(
                "ğŸ“ Enter your task description (will be created on default recipients):"
            )
            await state.set_state(RecipientState.waiting_for_task)
        
    except Exception as e:
        logger.error(f"Failed to start task creation for user {user_id}: {e}")
        await message.reply("Error starting task creation. Please try again.")


@router.message(Command('menu'))
async def show_main_menu(message: Message, state: FSMContext):
    """Show main menu."""
    keyboard = get_main_menu_keyboard()
    await message.reply(
        "ğŸ¯ **Main Menu**\n\nChoose what you'd like to do:",
        reply_markup=keyboard,
        parse_mode='Markdown'
    )


@router.message(Command('settings'))
async def show_settings(message: Message, state: FSMContext):
    """Show user settings."""
    user_id = message.from_user.id
    logger.info(f"Settings command called for user {user_id}")
    
    try:
        recipient_service = container.clean_recipient_service()
        prefs = recipient_service.get_user_preferences(user_id)
        logger.info(f"Retrieved prefs for user {user_id}: {prefs}")
        
        # Build settings display
        owner_name = prefs.owner_name if prefs and prefs.owner_name else "Not set"
        location = prefs.location if prefs and prefs.location else "Not set"
        notifications = "Enabled" if prefs and prefs.telegram_notifications else "Disabled"
        recipient_ui = "Enabled" if prefs and prefs.show_recipient_ui else "Disabled"
        
        text = f"âš™ï¸ **Your Settings**\n\n"
        text += f"ğŸ‘¤ **Name:** {owner_name}\n"
        text += f"ğŸŒ **Location:** {location}\n"
        text += f"ğŸ”” **Notifications:** {notifications}\n"
        text += f"ğŸ¯ **Recipient UI:** {recipient_ui}\n\n"
        text += "Select an option to update:"
        
        keyboard = get_settings_main_keyboard()
        await message.reply(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Failed to show settings for user {user_id}: {e}")
        await message.reply("Error loading settings. Please try again.")


@router.message(Command('drop_user_data'))
async def initiate_drop_user_data(message: Message, state: FSMContext):
    """Initiate user data deletion process."""
    keyboard = get_delete_confirmation_keyboard()
    await message.reply(
        "âš ï¸ **DELETE ALL DATA**\n\n"
        "This will permanently delete:\n"
        "â€¢ All your connected accounts\n"
        "â€¢ All shared recipients\n"  
        "â€¢ All your preferences\n"
        "â€¢ All associated data\n\n"
        "**This action cannot be undone!**\n\n"
        "Are you sure you want to continue?",
        reply_markup=keyboard,
        parse_mode='Markdown'
    )


@router.callback_query(lambda c: c.data.startswith("select_recipient_"))
async def handle_recipient_selection(callback_query: CallbackQuery, state: FSMContext):
    """Handle recipient selection for task creation."""
    recipient_id = callback_query.data.replace("select_recipient_", "")
    
    try:
        state_data = await state.get_data()
        selected_recipients = state_data.get('selected_recipients', [])
        
        # Toggle recipient selection
        if recipient_id in selected_recipients:
            selected_recipients.remove(recipient_id)
        else:
            selected_recipients.append(recipient_id)
        
        await state.update_data(selected_recipients=selected_recipients)
        
        # Update keyboard to show selection
        user_id = callback_query.from_user.id
        recipient_service = container.clean_recipient_service()
        recipients = recipient_service.get_enabled_recipients(user_id)
        
        keyboard = get_recipient_selection_keyboard(recipients, selected_recipients)
        
        selected_count = len(selected_recipients)
        await callback_query.message.edit_text(
            f"ğŸ¯ **Create Task**\n\n"
            f"Choose recipients for your task:\n"
            f"Selected: {selected_count} recipients",
            reply_markup=keyboard,
            parse_mode='Markdown'
        )
        
        await callback_query.answer(f"{'Added' if recipient_id in selected_recipients else 'Removed'} recipient")
        
    except Exception as e:
        logger.error(f"Failed to handle recipient selection: {e}")
        await callback_query.answer("Error updating selection")


@router.callback_query(lambda c: c.data == "confirm_recipients")
async def confirm_recipients(callback_query: CallbackQuery, state: FSMContext):
    """Confirm recipient selection and proceed to task input."""
    try:
        state_data = await state.get_data()
        selected_recipients = state_data.get('selected_recipients', [])
        
        if not selected_recipients:
            await callback_query.answer("Please select at least one recipient")
            return
        
        await callback_query.message.edit_text(
            f"ğŸ“ **Create Task**\n\n"
            f"Recipients selected: {len(selected_recipients)}\n\n"
            f"Now enter your task description:",
            parse_mode='Markdown'
        )
        
        await state.set_state(RecipientState.waiting_for_task)
        await callback_query.answer("Recipients confirmed!")
        
    except Exception as e:
        logger.error(f"Failed to confirm recipients: {e}")
        await callback_query.answer("Error confirming selection")


@router.callback_query(lambda c: c.data == "cancel_task")
async def cancel_task(callback_query: CallbackQuery, state: FSMContext):
    """Cancel task creation."""
    await state.clear()
    await callback_query.message.edit_text("âŒ Task creation cancelled.")
    await callback_query.answer()


@router.callback_query(lambda c: c.data == "transcribe_confirm")
async def confirm_transcription(callback_query: CallbackQuery, state: FSMContext):
    """Handle transcription confirmation."""
    try:
        data = await state.get_data()
        transcribed_text = data.get('transcribed_text')
        user_full_name = data.get('user_full_name', callback_query.from_user.full_name)
        user_id = callback_query.from_user.id
        
        if not transcribed_text:
            await callback_query.answer("âŒ No transcription data found")
            return
        
        # Process the transcribed text as a regular message
        await callback_query.message.edit_text("âœ… Creating task from voice message...")
        
        # Check if user has platforms configured
        recipient_service = container.clean_recipient_service()
        recipients = recipient_service.get_enabled_recipients(user_id)
        
        if not recipients:
            await callback_query.message.edit_text(
                "âŒ NO RECIPIENTS CONFIGURED\n\n"
                "You need to connect a recipient first!\n\n"
                "ğŸš€ Use /recipients to add your Todoist or Trello account."
            )
            await state.clear()
            return
        
        # Parse the transcribed text
        from core.initialization import services
        parsing_service = services.get_parsing_service()
        
        try:
            # Get user preferences for parsing context
            user_prefs = recipient_service.get_user_preferences(user_id)
            owner_name = user_prefs.owner_name if user_prefs else user_full_name
            location = user_prefs.location if user_prefs else None
            
            parsed_task_dict = parsing_service.parse_content_to_task(
                transcribed_text,
                owner_name=owner_name,
                location=location
            )
            
            if parsed_task_dict:
                task_data = TaskCreate(**parsed_task_dict)
            else:
                raise Exception("Parsing returned None")
                
        except Exception as e:
            logger.warning(f"Failed to parse transcribed text '{transcribed_text}' for user {user_id}: {e}")
            # Fallback: all tasks without time go to tomorrow 9AM UTC
            from datetime import datetime, timezone, timedelta
            from models.task import TaskCreate
            tomorrow = datetime.now(timezone.utc) + timedelta(days=1)
            due_time = tomorrow.replace(hour=9, minute=0, second=0, microsecond=0).isoformat()
            
            task_data = TaskCreate(
                title=transcribed_text,
                description=transcribed_text,
                due_time=due_time
            )
        
        # Create task using recipient task service
        task_service = container.clean_recipient_task_service()
        success, feedback, actions = task_service.create_task_for_recipients(
            user_id=user_id,
            title=task_data.title,
            description=task_data.description,
            specific_recipients=None  # Use default recipients
        )
        
        if success:
            # For voice tasks, we'll edit the existing message
            if actions and (actions.get("remove_actions") or actions.get("add_actions")):
                keyboard = get_post_task_actions_keyboard(actions)
                await callback_query.message.edit_text(feedback or "âœ… Task created!", reply_markup=keyboard, parse_mode='Markdown')
            else:
                await callback_query.message.edit_text(feedback or "âœ… Task created!", parse_mode='Markdown')
        else:
            await callback_query.message.edit_text(
                "âŒ Failed to create task from voice message.\n\n"
                "Please check your account configuration in /recipients"
            )
        
        await state.clear()
        
    except Exception as e:
        logger.error(f"Failed to confirm transcription: {e}")
        await callback_query.answer("âŒ Error processing voice message")
        await state.clear()


@router.callback_query(lambda c: c.data == "transcribe_cancel")
async def cancel_transcription(callback_query: CallbackQuery, state: FSMContext):
    """Handle transcription cancellation."""
    await state.clear()
    await callback_query.message.edit_text("âŒ Voice message transcription cancelled.")
    await callback_query.answer()


@router.callback_query(lambda c: c.data.startswith("add_task_to_"))
async def handle_add_task_to_recipient(callback_query: CallbackQuery):
    """Handle adding task to additional recipient."""
    try:
        # Parse recipient_id and task_id from callback data
        data_parts = callback_query.data.replace("add_task_to_", "").split("_")
        if len(data_parts) != 2:
            await callback_query.answer("âŒ Invalid data format")
            return
        
        recipient_id, task_id = data_parts
        user_id = callback_query.from_user.id
        
        # Get task service and add task to recipient
        task_service = container.clean_recipient_task_service()
        success, message = task_service.add_task_to_recipient(
            user_id=user_id,
            task_id=int(task_id),
            recipient_id=int(recipient_id)
        )
        
        if success:
            # Update message to show success
            await callback_query.message.edit_text(
                callback_query.message.text + f"\n\n{message}",
                parse_mode='Markdown',
                reply_markup=None  # Remove keyboard
            )
            await callback_query.answer("âœ… Task added successfully!")
        else:
            await callback_query.answer(f"âŒ {message}")
            
    except Exception as e:
        logger.error(f"Error adding task to recipient: {e}")
        await callback_query.answer("âŒ Error adding task")


@router.callback_query(lambda c: c.data.startswith("remove_task_from_"))
async def handle_remove_task_from_recipient(callback_query: CallbackQuery):
    """Handle removing task from a recipient."""
    try:
        # Parse recipient_id and task_id from callback data
        data_parts = callback_query.data.replace("remove_task_from_", "").split("_")
        if len(data_parts) != 2:
            await callback_query.answer("âŒ Invalid data format")
            return
        
        recipient_id, task_id = data_parts
        
        # For now, just acknowledge - removal is more complex as we need platform task IDs
        await callback_query.answer("âš ï¸ Task removal coming soon!")
        
        # Update message to show acknowledgment
        recipient_service = container.clean_recipient_service()
        recipient = recipient_service.get_recipient_by_id(callback_query.from_user.id, int(recipient_id))
        recipient_name = recipient.name if recipient else "recipient"
        
        await callback_query.message.edit_text(
            callback_query.message.text + f"\n\nâŒ _Removal from {recipient_name} coming soon_",
            parse_mode='Markdown',
            reply_markup=None
        )
            
    except Exception as e:
        logger.error(f"Error removing task from recipient: {e}")
        await callback_query.answer("âŒ Error removing task")


@router.callback_query(lambda c: c.data == "task_actions_done")
async def handle_task_actions_done(callback_query: CallbackQuery):
    """Handle completion of post-task actions."""
    # Remove the keyboard
    await callback_query.message.edit_reply_markup(reply_markup=None)
    await callback_query.answer("âœ… Done!")


@router.message(RecipientState.waiting_for_task)
async def handle_task_creation(message: Message, state: FSMContext):
    """Handle task creation with recipient system."""
    user_id = message.from_user.id
    task_description = message.text.strip()
    
    if not task_description:
        await message.reply("âŒ Task description cannot be empty. Please enter a description:")
        return
    
    try:
        state_data = await state.get_data()
        selected_recipients = state_data.get('selected_recipients', [])
        
        # Parse task description using AI to extract task details and timing
        from core.initialization import services
        parsing_service = services.get_parsing_service()
        
        try:
            # Get user info for proper parsing context
            recipient_service = container.clean_recipient_service()
            user_prefs = recipient_service.get_user_preferences(user_id)
            owner_name = user_prefs.owner_name if user_prefs else "User"
            location = user_prefs.location if user_prefs else None
            
            # Use the proper parsing method that handles time correctly
            parsed_task_dict = parsing_service.parse_content_to_task(
                task_description,
                owner_name=owner_name,
                location=location
            )
            
            if parsed_task_dict:
                task_data = TaskCreate(**parsed_task_dict)
            else:
                raise Exception("Parsing returned None")
                
        except Exception as e:
            logger.warning(f"Failed to parse task description '{task_description}' for user {user_id}: {e}")
            # Fallback: all tasks without time go to tomorrow 9AM UTC
            from datetime import datetime, timezone, timedelta
            from models.task import TaskCreate
            tomorrow = datetime.now(timezone.utc) + timedelta(days=1)
            due_time = tomorrow.replace(hour=9, minute=0, second=0, microsecond=0).isoformat()
            
            task_data = TaskCreate(
                title=task_description,
                description=task_description,
                due_time=due_time
            )
        
        # Create task using recipient task service
        task_service = container.clean_recipient_task_service()
        success, feedback, actions = task_service.create_task_for_recipients(
            user_id=user_id,
            title=task_data.title,
            description=task_data.description,
            specific_recipients=selected_recipients if selected_recipients else None
        )
        
        # Use unified response handler
        await handle_task_creation_response(message, success, feedback, actions)
        
        await state.clear()
        
    except Exception as e:
        logger.error(f"Failed to create task for user {user_id}: {e}")
        await message.reply("âŒ Error creating task. Please try again.")
        await state.clear()


@router.callback_query(lambda c: c.data == "back_to_recipients")
async def back_to_recipients(callback_query: CallbackQuery, state: FSMContext):
    """Go back to recipient management."""
    await state.clear()  # Clear any ongoing state
    await show_recipient_management_from_callback(callback_query)


async def handle_voice_message(message: Message, state: FSMContext, bot: Bot):
    """Handle voice message processing."""
    try:
        # Show processing message
        processing_msg = await message.answer("Processing voice message...")
        
        # Process voice message
        from core.initialization import services
        voice_service = services.get_voice_processing_service()
        voice_text = await voice_service.process_voice_message(message.voice, bot)
        await state.update_data(transcribed_text=voice_text)
        
        # Delete processing message
        await processing_msg.delete()
        
        # Determine the correct user name
        if message.forward_from:
            user_full_name = message.forward_from.full_name
        elif message.forward_sender_name:
            user_full_name = message.forward_sender_name
        else:
            user_full_name = message.from_user.full_name

        keyboard = get_transcription_keyboard()
        await message.answer(
            f"I transcribed your voice message as:\n\n{voice_text}\n\nIs this correct?",
            reply_markup=keyboard
        )
        
        # Store the user name for later use
        await state.update_data(user_full_name=user_full_name)
        
    except TranscriptionError as e:
        logger.error(f"Transcription error: {e}")
        await message.reply("Failed to transcribe your voice message. Please try again or send a text message.")
    except Exception as e:
        logger.error(f"Error handling voice message: {e}")
        await message.reply("An error occurred while processing your voice message.")


async def handle_photo_message(message: Message, state: FSMContext, bot: Bot):
    """Handle photo message processing with OCR and task creation."""
    try:
        processing_msg = await message.answer("ğŸ“¸ Processing screenshot...")
        
        from core.initialization import services
        image_service = services.get_image_processing_service()
        image_result = await image_service.process_image_message(message.photo, bot)
        
        await processing_msg.delete()
        
        extracted_text = image_result.get('extracted_text', '')
        summary = image_result.get('summary', '')
        
        if not extracted_text.strip():
            await message.reply(
                "ğŸ“¸ **Screenshot Processed**\n\n"
                f"ğŸ” **Analysis:** {summary}\n\n"
                "âš ï¸ No text was found in the image to create a task from."
            )
            return
        
        user_id = message.from_user.id
        recipient_service = container.clean_recipient_service()
        recipients = recipient_service.get_enabled_recipients(user_id)
        
        if not recipients:
            await message.reply(
                "âŒ NO RECIPIENTS CONFIGURED\n\n"
                "You need to connect a recipient first!\n\n"
                "ğŸš€ Use /recipients to add your Todoist or Trello account."
            )
            return
        
        user_full_name = message.from_user.full_name
        
        content_for_parsing = f"Screenshot content - {summary}. Text extracted: {extracted_text}"
        caption_text = message.caption or ""
        if caption_text:
            content_for_parsing = f"[CAPTION] {caption_text}\n[SCREENSHOT DESCRIPTION] {summary}\n[SCREENSHOT TEXT] {extracted_text}"
        
        # Get user preferences for parsing context
        user_prefs = recipient_service.get_user_preferences(user_id)
        owner_name = user_prefs.owner_name if user_prefs else user_full_name
        location = user_prefs.location if user_prefs else None
        
        from core.initialization import services
        parsing_service = services.get_parsing_service()
        
        try:
            parsed_task_dict = parsing_service.parse_content_to_task(
                content_for_parsing,
                owner_name=owner_name,
                location=location
            )
            
            if not parsed_task_dict:
                raise Exception("Parsing returned None")
                
            task_data = TaskCreate(**parsed_task_dict)
        except Exception as e:
            logger.warning(f"Failed to parse image content for user {user_id}: {e}")
            await message.reply(
                f"ğŸ“¸ **Screenshot Processed**\n\n"
                f"ğŸ” **Analysis:** {summary}\n\n"
                f"ğŸ“ **Text Found:** {extracted_text}\n\n"
                f"âš ï¸ Could not create a task from this content. Please send a message describing what you'd like to do with this information."
            )
            return
        
        # Create task using recipient task service
        task_service = container.clean_recipient_task_service()
        success, feedback, actions = task_service.create_task_for_recipients(
            user_id=user_id,
            title=task_data.title,
            description=task_data.description,
            specific_recipients=None  # Use default recipients
        )
        
        # Use unified response handler
        await handle_task_creation_response(message, success, feedback, actions)
        
    except Exception as e:
        logger.error(f"Error handling photo message: {e}")
        await message.reply("An error occurred while processing your screenshot.")


# State handlers for settings updates - MUST be before catch-all handler
@router.message(RecipientState.waiting_for_owner_name)
async def handle_owner_name_input(message: Message, state: FSMContext):
    """Handle owner name input."""
    user_id = message.from_user.id
    logger.info(f"Handle owner name input triggered for user {user_id}, message: '{message.text}'")
    owner_name = message.text.strip()
    
    if not owner_name:
        await message.reply("âŒ Name cannot be empty. Please enter your name:")
        return
    
    try:
        recipient_service = container.clean_recipient_service()
        logger.info(f"Attempting to update owner name for user {user_id} to '{owner_name}'")
        success = recipient_service.update_owner_name(user_id, owner_name)
        logger.info(f"Update owner name result: {success}")
        
        if success:
            await state.clear()
            keyboard = get_back_to_settings_keyboard()
            await message.reply(
                f"âœ… **Name Updated**\n\n"
                f"Your name has been set to: {owner_name}",
                reply_markup=keyboard,
                parse_mode='Markdown'
            )
        else:
            await message.reply("âŒ Failed to update name. Please try again.")
        
        await state.clear()
        
    except Exception as e:
        logger.error(f"Failed to update owner name for user {user_id}: {e}")
        await message.reply("âŒ Error updating name. Please try again.")
        await state.clear()


@router.message(RecipientState.waiting_for_location)
async def handle_location_input(message: Message, state: FSMContext):
    """Handle location input."""
    user_id = message.from_user.id
    location = message.text.strip()
    
    if not location:
        await message.reply("âŒ Location cannot be empty. Please enter your location:")
        return
    
    try:
        recipient_service = container.clean_recipient_service()
        success = recipient_service.update_location(user_id, location)
        
        if success:
            await state.clear()
            keyboard = get_back_to_settings_keyboard()
            await message.reply(
                f"âœ… **Location Updated**\n\n"
                f"Your location has been set to: {location}\n\n"
                f"This will be used for timezone handling in task scheduling.",
                reply_markup=keyboard,
                parse_mode='Markdown'
            )
        else:
            await message.reply("âŒ Failed to update location. Please try again.")
        
        await state.clear()
        
    except Exception as e:
        logger.error(f"Failed to update location for user {user_id}: {e}")
        await message.reply("âŒ Error updating location. Please try again.")
        await state.clear()


async def show_recipient_management_from_callback(callback_query: CallbackQuery):
    """Show unified recipient management from callback."""
    user_id = callback_query.from_user.id
    
    try:
        recipient_service = container.clean_recipient_service()
        all_recipients = recipient_service.get_all_recipients(user_id)
        
        # Generate display info
        personal_recipients = [r for r in all_recipients if r.is_personal]
        shared_recipients = [r for r in all_recipients if not r.is_personal]
        
        # Convert to display format
        personal_info = []
        for r in personal_recipients:
            personal_info.append({
                "id": r.id,
                "name": r.name,
                "platform_type": r.platform_type,
                "enabled": r.enabled,
                "status": "âœ… Active" if r.enabled else "âŒ Disabled"
            })
        
        available_info = []
        for r in shared_recipients:
            available_info.append({
                "id": r.id,
                "name": r.name,
                "platform_type": r.platform_type,
                "enabled": r.enabled,
                "status": "âœ… Active" if r.enabled else "âŒ Disabled"
            })
        
        display_info = {
            "personal": personal_info,
            "available": available_info,
            "total_personal": len(personal_recipients),
            "total_available": len(shared_recipients),
            "total_enabled_personal": len([p for p in personal_info if p["enabled"]]),
            "total_enabled_available": len([a for a in available_info if a["enabled"]])
        }
        
        keyboard = get_recipient_management_keyboard(all_recipients)
        
        if display_info["total_personal"] > 0 or display_info["total_available"] > 0:
            text = "ğŸ¯ **RECIPIENTS**\n\n"
            
            # Personal accounts section
            if display_info["total_personal"] > 0:
                text += "ğŸ‘¤ **Personal Accounts** *(Auto-selected for tasks)*\n"
                for personal in display_info["personal"]:
                    platform_emoji = "ğŸ“" if personal["platform_type"] == "todoist" else "ğŸ“‹"
                    text += f"  {platform_emoji} {personal['name']} - {personal['status']}\n"
                text += "\n"
            
            # Shared accounts section  
            if display_info["total_available"] > 0:
                text += "ğŸ‘¥ **Shared Accounts** *(Available to add)*\n"
                for available in display_info["available"]:
                    platform_emoji = "ğŸ“" if available["platform_type"] == "todoist" else "ğŸ“‹"
                    text += f"  {platform_emoji} {available['name']} - {available['status']}\n"
                text += "\n"
            
            # Summary
            total_enabled = display_info["total_enabled_personal"] + display_info["total_enabled_available"]
            text += f"ğŸ“Š **Summary:** {total_enabled} active recipients\n\n"
            text += "ğŸ’¡ Tap any recipient above to edit it."
        else:
            text = "ğŸ¯ **RECIPIENT SETUP**\n\n"
            text += "ğŸ‘‹ Welcome! You haven't connected any recipients yet.\n\n"
            text += "ğŸ¯ **What are recipients?**\n"
            text += "Recipients are accounts where your tasks will be created:\n"
            text += "â€¢ **Personal**: Your own Todoist/Trello (auto-selected)\n"
            text += "â€¢ **Shared**: Others' accounts you have access to\n\n"
            text += "ğŸš€ Get started by adding your first recipient below!"
        
        await callback_query.message.edit_text(text, reply_markup=keyboard, parse_mode='Markdown')
        await callback_query.answer()
        
    except Exception as e:
        logger.error(f"Failed to show recipient management: {e}")
        await callback_query.answer("Error loading recipient management")


# New menu and settings handlers
@router.callback_query(lambda c: c.data == "show_recipients")
async def show_recipients_callback(callback_query: CallbackQuery, state: FSMContext):
    """Show recipients from menu."""
    await show_recipient_management_from_callback(callback_query)


@router.callback_query(lambda c: c.data == "create_task")
async def create_task_callback(callback_query: CallbackQuery, state: FSMContext):
    """Create task from menu."""
    user_id = callback_query.from_user.id
    
    try:
        recipient_service = container.clean_recipient_service()
        recipients = recipient_service.get_enabled_recipients(user_id)
        
        if not recipients:
            await callback_query.message.edit_text(
                "âŒ NO RECIPIENTS CONFIGURED\n\n"
                "You need to connect a recipient first!\n\n"
                "ğŸš€ Use /recipients to add your Todoist or Trello account."
            )
            return
        
        # Check if recipient UI is enabled
        if recipient_service.is_recipient_ui_enabled(user_id):
            # Show recipient selection
            keyboard = get_recipient_selection_keyboard(recipients, [])
            
            await callback_query.message.edit_text(
                "ğŸ¯ **Create Task**\n\n"
                "First, choose recipients for your task:",
                reply_markup=keyboard,
                parse_mode='Markdown'
            )
            
            await state.set_state(RecipientState.selecting_recipients)
            await state.update_data(selected_recipients=[])
        else:
            # Use default recipients
            await callback_query.message.edit_text(
                "ğŸ“ Enter your task description (will be created on default recipients):"
            )
            await state.set_state(RecipientState.waiting_for_task)
        
        await callback_query.answer()
        
    except Exception as e:
        logger.error(f"Failed to start task creation for user {user_id}: {e}")
        await callback_query.answer("Error starting task creation")


@router.callback_query(lambda c: c.data == "show_settings")
async def show_settings_callback(callback_query: CallbackQuery, state: FSMContext):
    """Show settings from menu."""
    user_id = callback_query.from_user.id
    
    try:
        recipient_service = container.clean_recipient_service()
        prefs = recipient_service.get_user_preferences(user_id)
        
        # Build settings display
        owner_name = prefs.owner_name if prefs and prefs.owner_name else "Not set"
        location = prefs.location if prefs and prefs.location else "Not set"
        notifications = "Enabled" if prefs and prefs.telegram_notifications else "Disabled"
        recipient_ui = "Enabled" if prefs and prefs.show_recipient_ui else "Disabled"
        
        text = f"âš™ï¸ **Your Settings**\n\n"
        text += f"ğŸ‘¤ **Name:** {owner_name}\n"
        text += f"ğŸŒ **Location:** {location}\n"
        text += f"ğŸ”” **Notifications:** {notifications}\n"
        text += f"ğŸ¯ **Recipient UI:** {recipient_ui}\n\n"
        text += "Select an option to update:"
        
        keyboard = get_settings_main_keyboard()
        await callback_query.message.edit_text(text, reply_markup=keyboard, parse_mode='Markdown')
        await callback_query.answer()
        
    except Exception as e:
        logger.error(f"Failed to show settings for user {user_id}: {e}")
        await callback_query.answer("Error loading settings")


@router.callback_query(lambda c: c.data == "back_to_menu")
async def back_to_menu(callback_query: CallbackQuery, state: FSMContext):
    """Go back to main menu."""
    keyboard = get_main_menu_keyboard()
    await callback_query.message.edit_text(
        "ğŸ¯ **Main Menu**\n\nChoose what you'd like to do:",
        reply_markup=keyboard,
        parse_mode='Markdown'
    )
    await callback_query.answer()


@router.callback_query(lambda c: c.data == "back_to_settings")
async def back_to_settings_callback(callback_query: CallbackQuery, state: FSMContext):
    """Go back to settings menu."""
    await show_settings_callback(callback_query, state)


@router.callback_query(lambda c: c.data == "profile_settings")
async def profile_settings_callback(callback_query: CallbackQuery, state: FSMContext):
    """Show profile settings menu."""
    from keyboards.recipient import get_profile_settings_keyboard
    
    keyboard = get_profile_settings_keyboard()
    
    await callback_query.message.edit_text(
        "ğŸ‘¤ **Profile Settings**\n\n"
        "Manage your personal information:",
        reply_markup=keyboard,
        parse_mode='Markdown'
    )
    await callback_query.answer()


@router.callback_query(lambda c: c.data == "update_owner_name")
async def update_owner_name_callback(callback_query: CallbackQuery, state: FSMContext):
    """Start owner name update process."""
    logger.info(f"Update owner name callback triggered for user {callback_query.from_user.id}")
    await callback_query.message.edit_text(
        "ğŸ‘¤ **Update Your Name**\n\n"
        "Enter your name (this helps with personalized task creation):",
        parse_mode='Markdown'
    )
    await state.set_state(RecipientState.waiting_for_owner_name)
    logger.info(f"Set state to waiting_for_owner_name for user {callback_query.from_user.id}")
    await callback_query.answer()


@router.callback_query(lambda c: c.data == "update_location")
async def update_location_callback(callback_query: CallbackQuery, state: FSMContext):
    """Start location update process."""
    await callback_query.message.edit_text(
        "ğŸŒ **Update Your Location**\n\n"
        "Enter your location (for timezone handling):\n"
        "Examples: Portugal, Cascais, New York, California, UK",
        parse_mode='Markdown'
    )
    await state.set_state(RecipientState.waiting_for_location)
    await callback_query.answer()


@router.callback_query(lambda c: c.data == "notification_settings")
async def notification_settings_callback(callback_query: CallbackQuery, state: FSMContext):
    """Show notification settings."""
    user_id = callback_query.from_user.id
    logger.error(f"ğŸ” NOTIFICATION SETTINGS called for user {user_id}")
    
    try:
        recipient_service = container.clean_recipient_service()
        prefs = recipient_service.get_user_preferences(user_id)
        
        notifications = "Enabled" if prefs and prefs.telegram_notifications else "Disabled"
        recipient_ui = "Enabled" if prefs and prefs.show_recipient_ui else "Disabled"
        
        text = f"ğŸ”” **Notification Settings**\n\n"
        text += f"Telegram Notifications: {notifications}\n"
        text += f"Recipient Selection UI: {recipient_ui}\n\n"
        text += "â€¢ Notifications: Get Telegram reminders for due tasks\n"
        text += "â€¢ Recipient UI: Choose recipients for each task"
        
        keyboard = get_notification_settings_keyboard()
        await callback_query.message.edit_text(text, reply_markup=keyboard, parse_mode='Markdown')
        await callback_query.answer()
        
    except Exception as e:
        logger.error(f"Failed to show notification settings for user {user_id}: {e}")
        await callback_query.answer("Error loading notification settings")


@router.callback_query(lambda c: c.data == "confirm_delete_data")
async def confirm_delete_data_callback(callback_query: CallbackQuery, state: FSMContext):
    """Show data deletion confirmation."""
    keyboard = get_delete_confirmation_keyboard()
    await callback_query.message.edit_text(
        "âš ï¸ **FINAL CONFIRMATION**\n\n"
        "ğŸš¨ **THIS WILL PERMANENTLY DELETE:**\n"
        "â€¢ All connected accounts (Todoist, Trello)\n"
        "â€¢ All shared recipients\n"
        "â€¢ All preferences and settings\n"
        "â€¢ All task history associations\n\n"
        "**THIS CANNOT BE UNDONE!**\n\n"
        "Are you absolutely sure?",
        reply_markup=keyboard,
        parse_mode='Markdown'
    )
    await callback_query.answer()


@router.callback_query(lambda c: c.data == "delete_all_data_confirmed")
async def delete_all_data_confirmed(callback_query: CallbackQuery, state: FSMContext):
    """Execute data deletion."""
    user_id = callback_query.from_user.id
    
    try:
        recipient_service = container.clean_recipient_service()
        success = recipient_service.delete_all_user_data(user_id)
        
        if success:
            await callback_query.message.edit_text(
                "âœ… **All Data Deleted**\n\n"
                "Your data has been permanently removed.\n"
                "You can start fresh by using /start",
                parse_mode='Markdown'
            )
        else:
            await callback_query.message.edit_text(
                "âŒ **Deletion Failed**\n\n"
                "There was an error deleting your data.\n"
                "Please try again or contact support.",
                parse_mode='Markdown'
            )
        
        await callback_query.answer()
        await state.clear()
        
    except Exception as e:
        logger.error(f"Failed to delete data for user {user_id}: {e}")
        await callback_query.answer("Error deleting data")


# RESTORED THREADING MESSAGE HANDLER
@router.message()
async def handle_regular_message_with_threading(message: Message, state: FSMContext, bot: Bot = None):
    """Handle regular messages with threading support - groups messages within 1 second."""
    # Skip if in a specific state
    current_state = await state.get_state()
    if current_state:
        return
    
    # Handle voice messages
    if message.voice:
        await handle_voice_message(message, state, bot)
        return
    
    user_id = message.from_user.id
    text = message.text
    
    # Handle both text and photos through unified threading system
    if message.photo or message.document:
        # For photos/documents, use caption as text
        caption_text = message.caption or ""
        await process_user_input_with_photo(
            caption_text,  # Use caption for photos, not message.text
            user_id, 
            message, 
            state,
            bot
        )
    elif text and not text.startswith('/'):
        # Use threading system for text messages
        await process_user_input(text, user_id, message, state)

